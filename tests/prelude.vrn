(def q (vau (a) % a))
(def cons (wrap/snc qcons))
(def cons/rtl (wrap/rtl qcons))
(def car (wrap/rtl qcar))
(def cdr (wrap/rtl qcdr))
(def list (wrap/snc qlist))
(def list/rtl (wrap/rtl qlist))
(def seq (wrap/rtl last))
(def par (wrap/snc last))
(def qns (vau (e b) % (e b)))
(def ns (wrap/rtl qns))
(def cur-env (vau () % %))
(def new-env (vau () % (cur-env)))
(def read (wrap/rtl qread))
(def eq? (wrap/snc qeq?))
(def eq?/rtl (wrap/rtl qeq?))
(def qnil? (vau (a) % (eq? a ())))
(def nil? (wrap/rtl qnil?))
(def & (vau a % ((nil? a) #t ((% (car a)) (% (cons & (cdr a)) #f)))))
(def | (vau a % ((nil? a) #f ((% (car a)) #t (% (cons | (cdr a)))))))
(def qxor (vau (a b) % (a (b #f #t) (b #t #f))))
(def ^ (wrap/snc qxor))
(def call/cc (vau (fn) % (bind/cc k (fn k))))
(def * (wrap/snc '*))
(def */rtl (wrap/rtl '*))
(def / (wrap/snc '/))
(def //rtl (wrap/rtl '/))
(def + (wrap/snc '+))
(def +/rtl (wrap/rtl '+))
(def - (wrap/snc '-))
(def -/rtl (wrap/rtl '-))
(def < (wrap/rtl '<))
(def < (wrap/rtl '<))
(def <= (wrap/rtl '<=))
(def <= (wrap/rtl '<=))
(def > (wrap/rtl '>))
(def > (wrap/rtl '>))
(def >= (wrap/rtl '>=))
(def >= (wrap/rtl '>=))
(def sym? (wrap/rtl qsym?))
(def str? (wrap/rtl qstr?))
(def bool? (wrap/rtl qbool?))
(def num? (wrap/rtl qnum?))
(def pair? (wrap/rtl qpair?))
(def qnot (vau (a) % (a #f #t)))
(def not (wrap/rtl qnot))
(def fn/snc
	(vau (args body) %
		(wrap/snc (% (list/rtl vau args ## body)))))
(def fn/rtl
	(vau (args body) %
		(wrap/rtl (% (list/rtl vau args ## body)))))
(def unwrap (wrap/rtl qunwrap))
(def '@ (vau (p args) %
	(% (cons p args))))
(def @ (wrap/rtl '@))
(def qcall (vau (p . args) %
	(% (cons (unwrap p) args))))
(def call (wrap/snc qcall))
(def call/rtl (wrap/rtl qcall))

(def rec (fn/rtl (f) (vau a % (% (cons f (cons f a))))))
(def rec/vau (vau (args e body) % (seq
	(def f (% (list/rtl vau (cons (q self) args) e body)))
	(vau args v (v f (cons f args))))))
(def rec/snc (vau (args body) % (seq
	(def f (wrap/snc (% (list/rtl vau (cons (q self) args) e body))))
	(vau args e (e f (cons f args))))))
(def rec/rtl (vau (args body) % (seq
	(def f (wrap/rtl (% (list/rtl vau (cons (q self) args) e body))))
	(vau args e (e f (cons f args))))))

(def map (rec (fn/rtl (self f l) ((nil? l) l (cons (f (car l)) (self f (cdr l))))))
(def map/snc (fn/rtl (f l) (@ list (map (vau (e) % (list f (% e))) l))))
(def for/snc (vau (i range body) %
	(map/snc (call/rtl vau (list i) ## body) (% range))))

(def unique (wrap/rtl qunique))
(def macro (vau (args body) %
	(seq 	(def e (unique body))
		(call/rtl vau args e (list % (list e body))))))

(def let (vau (bindings body) ##
	(@	(wrap/snc (call/rtl vau (map car bindings) ## body))
		(map cdr bindings))))

(def print (wrap/snc qprint))
(def println (fn/snc a % (seq (@ print a) (qprint "
"))))

(def check (vau (a b name) % (seq
	(def va (% a))
	(def vb (% b))
	((eq? va vb)
		(println "Passed " name)
		(println "Failed " name ": " a " = " va ", " b " = " vb)))))
(def cond (vau opts eval
	((nil? opts) ()
		(seq
			(def opt (car opts))
			(def test (eval (car opt)))
			((bool? test)
				(eval (test
					(car (cdr opt))
					(cons cond (cdr opts))))
				(panic "Non-boolean condition"))))))
