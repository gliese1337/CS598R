(def q (vau (a) % a))
(def cons (wrap/snc qcons))
(def cons/ltr (wrap/ltr qcons))
(def car (wrap/ltr qcar))
(def cdr (wrap/ltr qcdr))
(def list (wrap/snc qlist))
(def list/ltr (wrap/ltr qlist))
(def seq (wrap/ltr last))
(def par (wrap/snc last))
(def qns (vau (e b) % (e b)))
(def ns (wrap/ltr qns))
(def cur-env (vau () % %))
(def new-env (vau () % (cur-env)))
(def read (wrap/ltr qread))
(def eq? (wrap/snc qeq?))
(def eq?/ltr (wrap/ltr qeq?))
(def qnil? (vau (a) % (eq? a ())))
(def nil? (wrap/ltr qnil?))
(def & (vau a % ((nil? a) #t ((% (car a)) (% (cons & (cdr a)) #f)))))
(def | (vau a % ((nil? a) #f ((% (car a)) #t (% (cons | (cdr a)))))))
(def qxor (vau (a b) % (a (b #f #t) (b #t #f))))
(def ^ (wrap/snc qxor))
(def call/cc (vau (fn) % (bind/cc k (fn k))))
(def * (wrap/snc '*))
(def */ltr (wrap/ltr '*))
(def / (wrap/snc '/))
(def //ltr (wrap/ltr '/))
(def + (wrap/snc '+))
(def +/ltr (wrap/ltr '+))
(def - (wrap/snc '-))
(def -/ltr (wrap/ltr '-))
(def < (wrap/snc '<))
(def </ltr (wrap/ltr '<))
(def <= (wrap/snc '<=))
(def <=/ltr (wrap/ltr '<=))
(def > (wrap/snc '>))
(def >/ltr (wrap/ltr '>))
(def >= (wrap/snc '>=))
(def >=/ltr (wrap/ltr '>=))
(def sym? (wrap/ltr qsym?))
(def str? (wrap/ltr qstr?))
(def bool? (wrap/ltr qbool?))
(def num? (wrap/ltr qnum?))
(def pair? (wrap/ltr qpair?))
(def qnot (vau (a) % (a #f #t)))
(def not (wrap/ltr qnot))
(def fn/snc
	(vau (args body) %
		(wrap/snc (% (list/ltr vau args (q ##) body)))))
(def fn/ltr
	(vau (args body) %
		(wrap/ltr (% (list/ltr vau args (q ##) body)))))
(def unwrap (wrap/ltr qunwrap))
(def '@ (vau (p args) %
	(% (cons (unwrap p) args))))
(def @/ltr (wrap/ltr '@))
(def qcall (vau (p . args) %
	(% (cons p args))))
(def call (wrap/snc qcall))
(def call/ltr (wrap/ltr qcall))

(def print (wrap qprint))

(def check (vau (a b name) % 
	(def va (% a))
	(def vb (% b))
	((eq? va vb)
		(print "Passed " name "
")
		(print "Failed " name ": " a " = " va ", " b " = " vb "
"))))
(def cond (vau opts eval
	((nil? opts) ()
		(seq
			(def opt (car opts))
			(def test (eval (car opt)))
			((bool? test)
				(eval (test
					(car (cdr opt))
					(cons cond (cdr opts))))
				(panic "Non-boolean condition"))))))

(check (car (qcons a b)) (q a) "'car'/'qcons' test 1")
(check (car (qcons (a b) c)) (q (a b)) "'car'/'qcons' test 2")
(check (cdr (qcons a (b c))) (q (b c)) "'car'/'qcons' test 3")
(check (qcar (cons a b)) (q cons) "'qcar'/'cons' test")
(check (car (cons #t #f)) #t "'car'/'cons' test")
(check (cdr (cons #t #f)) #f "'cdr'/'cons' test")
(check (last car cdr cons) (q cons) "'last' test")
(check (seq car cdr cons) cons "'seq' test")
(check (bind/cc k (seq #t (k #f) car cdr)) #f "'bind/cc' test")
(check (@/ltr cons (q (a b))) (q (a . b)) "@ test")
(check (call/ltr qcons (q a) (q b)) (q ( a . b)) "call test")
(def var (vau (a . b) % b))
(check (var a b c d) (qlist b c d) "variadic test 1")
(check (call/ltr var 1 2 3 4) (qlist 2 3 4) "variadic test 2")
(check (cond) () "empty cond")
(check (cond (#t "result"))
	"result"
	"cond test 1")
(check (cond
	(#f "false")
	(#t "true"))
	"true"
	"cond test 2")
(check (cond
	(#f "hello")
	((nil? 5) "yo")
	((car (qlist #t #f)) "result"))
	"result"
	"cond test 3")
